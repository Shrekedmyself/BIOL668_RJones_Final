---
title: "RJones_Exp001_NPC_A"
author: "Riley Jones"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Librarying:
```{r, warning = F, echo = F, include=FALSE}
library(tidyverse)
library(BiocManager)
library(Seurat)
library(DoubletFinder)
library(patchwork)
library(Matrix)
library(presto)
library(sctransform)
library(glmGamPoi)
library(SingleR)
library(celldex)
library(pheatmap)
library(scran)
set.seed(777)
rm(list = ls())
```

# Preprocessing

If you want to do the analysis yourself, you must do the following: 
1) Download the 'GSM4929846_NPC_SC_1802_Tumor_count.csv.gz' file from here: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE162025 (renamed to ''GSE162025_Tumor_count_A.csv' in this file)
2) Untar and gunzip the file
3) In Excel with your .csv: YOU MUST MAKE SURE YOUR EXCEL DOES NOT IMPORT VALUES TO DATES. This can affect genes like 'MARC1', 'MARCH1', 'MARC2', 'MARCH2', etc. You must insert a blank cell in A1 to make sure that your all of your columns (unique cells) line up with your gene counts. Make sure the first column does not line up with your gene names.
4) In TextEdit (or similar program), insert a comma (',') at the beginning of your .csv file.
5) After doing either 3 or 4, you can import into R.
6) Note, this file will not knit as is (takes a very long time during the singleR cell annotation step and will time out)

## Creating a Seurat object and initial steps

### Loading the dataset 

```{r, echo = F, warning = F}
citation(package = 'Seurat')
current_seurat <- read.csv('GSE162025_Tumor_count_A.csv', row.names = 1, header = T, sep = ',', check.names = F)

current_seurat <- as.sparse(current_seurat)
#Creating a sparse matrix to save space

current_seurat_v5 <- CreateAssay5Object(counts = current_seurat)
#Creating an 'Assay5Object' for proper loading into Seurat
```

# SCTransformation and dimensional reduction

## SCTransform, PCA, FindNeighbors, UMAP, and FindClusters
This will normalize and scale the data (SCTransform reference: Choudhary & Satija, **Genome Bio.** 2022). 
```{r, echo = F}
citation(package = 'sctransform')
#Working with our Current Seurat Object ('cso')

cso <- CreateSeuratObject(current_seurat_v5) %>% #Creating a Seurat Object
    PercentageFeatureSet(pattern = "^MT-", col.name = "percent.mt") %>% 
    #Analyzing the percent mitochondrial genes for each cell. We need to do this to remove cells that are dead or had improper seq.
    subset(subset = nCount_RNA >= 101 & nFeature_RNA >= 501 & percent.mt <= 15) %>%  
    #Subsetting the cells based upon the if they had >= 101 RNA reads, >= 500 genes counted, and <= 15% mitochondrial reads
    SCTransform(vars.to.regress = "percent.mt") %>%
    #Running SCTransform on our data and regressing out the mitochondrial gene percentage
    FindVariableFeatures() %>% 
    #Identify features/genes that are outliers
    RunPCA() %>%
    #Running PCA
    FindNeighbors(dims = 1:20) %>%
    #Using a K-nearest neighbors approach and Euclidean distance to calculate (Jaccard) similarity between clusters
    RunUMAP(dims = 1:20, label = TRUE) %>%
    #Visualization of independent non-linear dimensional reduction
    FindClusters()
    #Clustering the cells based upon similarity matrix from `FindNeighbors()`

#Figure 1: Elbow Plot with Standard Deviation of Principal Components
#The figure generated by the code below will show the standard deviation of the variation caused by each the principal components up until a specified number of dimensions. Where the "elbow" of the plot dips is where it is the best to cutoff. The authors in the original paper used 20 dimensions/PCs for their analyses, which we can see was the right choice with the Elbow Plot below. 
ElbowPlot(cso, ndims = 30, reduction = 'pca')

cso$patient <- 'Patient_1802'
cso$site <- 'Tumor'

#Figure 2: UMAP plot of Cell Clusters
#The UMAP plot below will show cells clustered together based upon their shared variation. This variation is caused by sets of genes which in turn are based upon their cellular identity, i.e. different cell types will express different sets of genes. More similar cell types will cluster closer together than less similar cell types.
DimPlot(cso, reduction = 'umap', label = TRUE)
```

# Non-SCT QC method (replaced by SCT)
Note, this is the previous QC method that the Satija lab had replaced with SCT, won't go into detail as this won't be used for downstream analysis
```{r, echo = F, include = F}
cs_counts <- GetAssayData(current_seurat_v5, slot = 'counts')
cso_non_SCT <- CreateSeuratObject(cs_counts)
cso_non_SCT$mitoPercent <- PercentageFeatureSet(cso_non_SCT, pattern = '^MT-')

cso_non_SCT_subset <- subset(cso_non_SCT, subset = nCount_RNA >= 101 &
         nFeature_RNA >= 501 &
         mitoPercent <= 15)

current_seurat_v5
cso_non_SCT

# pre-process standard workflow
cso_non_SCT <- NormalizeData(object = cso_non_SCT)
cso_non_SCT <- FindVariableFeatures(object = cso_non_SCT)
cso_non_SCT <- ScaleData(object = cso_non_SCT)
cso_non_SCT <- RunPCA(object = cso_non_SCT)
ElbowPlot(cso_non_SCT)
cso_non_SCT <- FindNeighbors(object = cso_non_SCT, dims = 1:20)
cso_non_SCT <- FindClusters(object = cso_non_SCT)
cso_non_SCT <- RunUMAP(object = cso_non_SCT, dims = 1:20)
DimPlot(cso_non_SCT, reduction = 'umap', label = TRUE)
```

# DoubletFinder [insert citation for DoubletFinder here]
DoubletFinder, 
```{r, echo = F}
citation(package = 'DoubletFinder')
#pK Identification (This defines the PC neighborhood size used to compute pANN, expressed as a proportion of the merged real-artificial data. No default is set, as pK should be adjusted for each scRNA-seq dataset)
#No ground-truth as we are using real data

print('This next step will take a long time just FYI')

sweep.res.list_cso <- paramSweep(cso, PCs = 1:20, sct = TRUE)
#This will introduce artificial doublets in varying proportions into your dataset and then test for the optimal pK value.
#It will then also do some QC on your data and calculate artificial nearest neighbors of varying neighborhood sizes
#It will also provide you with a list of artificial nearest neighbors for varying values of pN/pK

sweep.stats_cso <- summarizeSweep(sweep.res.list_cso, GT = FALSE)
#Summarizes results of the previous step

bcmvn_cso <- find.pK(sweep.stats_cso)
head(bcmvn_cso)
#Computes a metric by which we can find the optimal pK value using mean variance after normalization. The highest value will then become the optimal pK value
#Will provide mean and variance in a df format as well as the mean-variance-normalized bimodality coefficient (BCmvn)

#Viewing the pK values as a graph with the pK value on the x-axis, the BCmetric
ggplot(bcmvn_cso, aes(pK, BCmetric, group = 1)) +
  geom_point() +
  geom_line()
#In this case, the optimal pK value is 0.21

#Select the pK that corresponds to max bcmvn to optimize doublet detection
pK <- bcmvn_cso %>% 
  filter(BCmetric == max(BCmetric)) %>%
  select(pK) 
pK <- as.numeric(as.character(pK[[1]]))

## Homotypic Doublet Proportion Estimate
#Modeling doublets of the same cell/type in the data

annotations <- cso@meta.data$seurat_clusters
#Saving our cell clusters for each cell

homotypic.prop <- modelHomotypic(annotations)
print(homotypic.prop*100)
#Modeling homotypic doublets based upon our cell clusters from our data after `FindClusters()` and will give you a rate of expected homotypic doublets

nExp_poi <- round(0.05*nrow(cso@meta.data))  
## Assuming 5.0% doublet formation rate - tailor for your dataset and will give us the expect number of homotypic doublets
#In this case, 732

nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))
#Multiplying the number of homotypic doublets from previous step by the proportion of non-doublets and will give us our expected number of doublets after adjusting for homotypic doublets and will give the expected number of doublets ( still don't completely understand so sorry if confusing)
#In this case, 662 real doublets after homotypic doublet correction

#Running `doubletfinder()`
print('This will also take a long time')
cso <- doubletFinder(cso, 
                     PCs = 1:10, 
                     pN = 0.25, 
                     pK = pK, 
                     nExp = nExp_poi.adj,
                     reuse.pANN = FALSE, sct = TRUE)
#Setting `reuse.pANN = F` as this is our first run of doublet finder and we do not have previously saved results


#Figure 3: Doublet Visualization for our scRNAseq data
DimPlot(cso, reduction = 'umap', group.by = "DF.classifications_0.25_0.21_439")
#If for some reason this does not work, use `view(cso@meta.data)` and go to the column similar to the `group.by` argument above and then change the name in the above call to match the column

#Table of singlets and doublets
table(cso@meta.data$DF.classifications_0.25_0.21_439)

#Removing doublets
singles_only <- cso[, cso@meta.data$DF.classifications_0.25_0.21_439 == "Singlet"]
#If for some reason this does not work, use `view(cso@meta.data)` and go to the column similar to the `group.by` argument above and then change the name in the above call to match the column
```

# SingleR annotation
SingleR reference: Aran et al, 2019, **Nat Immuno**
Using the Human Primary Cell Atlas reference database to annotate the cell clusters in our dataset
```{r, echo = F}
citation(package = 'celldex')
citation(package = 'SingleR')
#Getting reference data for our cell types from the Human Primary Cell Atlas
HPCA <- celldex::HumanPrimaryCellAtlasData()

#Creating a counts object (numeric matrix of single-cell expression values where rows are genes and columns are cells) for our expression data 
single_counts <- GetAssayData(singles_only, layer = 'counts')

#Predicting and annotating our cells with SingleR using our HPCA references and our cell type labels from the same
print('This will also take a bit')
pred_single <- SingleR(test = single_counts, ref = HPCA, labels = HPCA$label.fine)
#Using `labels = HPCA$labels.fine` as we want more finely detailed cell type annotation

#Adding our cell type labels to our Seurat object metadata
singles_only$singleR.labels <- pred_single$labels[match(rownames(singles_only@meta.data), rownames(pred_single))]

#Creating a UMAP plot with our annotated cell types
#DimPlot(singles_only, reduction = 'umap', group.by = 'singleR.labels', repel = T, ) 
#Can add `label = TRUE, label.size = #` as well

#Figure 4: Cell type annotation of cells infiltrating a patient NPC tumor
Dim1 <- DimPlot(singles_only, reduction = 'umap', group.by = 'singleR.labels') + NoLegend()
LabelClusters(plot = Dim1, id = 'singleR.labels')
#Same as above but no legend

#SingleR annotation diagnostics
#pred_current_seurat$scores
#plotScoreHeatmap(pred_current_seurat)
#Commenting these ones out since they're not as useful

#plotDeltaDistribution(pred_current_seurat)
#This will show you cells that were cut off from being annotated as certain cell types based upon the strength of their annotation

#Table of each cell type annotation by UMAP cluster
#cell.cluster.table <- table(Assigned=pred_current_seurat$labels, Clusters=singles_only$seurat_clusters)
#cell.cluster.table

#Creating a df of our singleR labels
singleR_labels_df <- singles_only@meta.data %>%
  select(singleR.labels)

#Create the frequency table for our cell types
freq_table <- table(singleR_labels_df$singleR.labels)

#Convert the frequency table to a data frame
singleR_labels_df <- as.data.frame(freq_table)

#Calculating the total of cell subtypes
total_count <- sum(singleR_labels_df$Freq)

#Adding the Proportion column to our dataframe
singleR_labels_df$Proportion <- singleR_labels_df$Freq / total_count

#Viewing the cell subtype frequencies and proportions
singleR_labels_df <- singleR_labels_df %>%
  arrange(desc(Freq)) %>%
  slice_head(n = 25)

#Print the resulting data frame
print(singleR_labels_df)

#Renaming the columns
colnames(singleR_labels_df) <- c("CellType", "Frequency", "Proportion")

#Filtering cell types using regular expressions to include only parent cell types (such a 'B_cell' rather than 'B_cell:Memory' or 'B_cell:Plasma_cell')
filtered_labels <- singleR_labels_df %>%
  filter(grepl("^B_cell|^T_cell|^NK_cell|^Monocyte|^Epithelial_cells|^Macrophage|^DC|^GMP|^GMP|^Pre-B_cell", CellType))
#Note, can add other parent cell types as well including  "^Endothelial_cells", "^iPS_cells","^Keratinocytes", "^Neutrophil", "^Pre-B_cell"
#For this specific sample, only included ones that had a sum > 10 cells however this may be different for other samples

filtered_sum <- sum(filtered_labels$Frequency)

#Aggregate counts of parent cell types
cell_type_counts_sum <- filtered_labels %>%
  mutate(CellType = gsub(":.*", "", CellType), Proportion = Proportion *100) %>%  #Removeing subtypes
  group_by(CellType) %>%
  summarise(Count = sum(Frequency), Proportion = sum(Proportion)) %>% 
  arrange(desc(Count))

#Show the summed cell types
print(cell_type_counts_sum)

#Figure 5: Cell type proportions of the tumor microenvironment of an EBV+ NPC tumor
ggplot(cell_type_counts_sum, aes(x = "", y = Proportion, fill = CellType)) +
  geom_bar(stat = "identity") +
  labs(x = NULL, y = "Proportion (%)", title = "Stacked Bar Plot of Cell Type Proportions") +
  scale_fill_discrete(name = "Cell Type") +
  theme_minimal()  
  
#This will show the correlation between a cluster and that assigned cell type with red being stronger correlation
#pheatmap(log10(cell.cluster.table+10), color = colorRampPalette(c('white','red'))(10))
```

# Differentially expressed features
Finding differentially expressed features (cluster biomarkers)
    -This will help you identify positive and negative markers of single cluster compared to all other cells
        --`FindAllMarker()` will automate this process for all clusters but you can test groups of clusters against each other or against all cells
```{r, echo = F}
#Simple view of the top 6 genes up/down regulated for each PC
print(singles_only[['pca']], dims = 1:20, nfeatures = 6)

#Find markers for every cluster compared to all remaining cells, reporting only the positive ones
singles_only.markers <- FindAllMarkers(singles_only, only.pos = T, min.pct = 0.25, logfc.threshold = 0.5) 
#If you want both positive and negative markers, put `only.pos = F`

#Getting the top 6 genes per cluster with a average log2 fold change of >1 (upregulated genes)
singles_only.markers %>%
    group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 1) %>%
    slice_head(n = 6) %>%
    ungroup() -> top6

#Alternatively
#current_seurat.markers %>%
  #group_by(cluster) %>%
  #dplyr::filter(avg_log2FC >1)

#Getting the markers for one cluster, cluster 0
cluster0.markers <- FindMarkers(singles_only, ident.1 = 0, logfc.threshold = 0.25, test.use = 'roc', only.pos = T) 
#Specifying that we are using the ROC test to return the "classification power" for any individual marker ranging from 0 (random) to 1 (perfect)

#Extracting marker genes for each cluster
marker_genes <- lapply(unique(singles_only.markers$cluster), function(cluster_id) {
  markers_subset <- subset(singles_only.markers, cluster == cluster_id)
  top_markers <- head(markers_subset[order(-markers_subset$avg_log2FC), ], n = 5)  # Adjust the number of markers as needed
  top_markers$gene
})

#Creating a list of potential cell types based upon our genes from 'marker_genes'
cell_ids <- c(
  "B Cell: Memory",
  "B Cell: Follicular",
  "B Cell: Marginal Zone",
  "B Cell: Germinal Center",
  "B Cell: Plasma",
  "T Cell: Naive",
  "T Cell: Effector",
  "B Cell: Progenitor",
  "Epithelial Cell",
  "Plasma Cell?",
  "T Cell: Regulatory",
  "T Cell: Regulatory",
  "T Cell: Effector",
  "B Cell: Plasma",
  "Unknown: Dendritic Cell?",
  "Unknown: Stromal Cell?",
  "Unknown: Lymphocyte?",
  "Unknown: Epithelial Cell?",
  "Unknown: Mast Cell?",
  "Unknown: Immune Cell?"
)

#Renaming things
names(cell_ids) <- levels(singles_only)
singles_only <- RenameIdents(singles_only, cell_ids)
Idents(singles_only) <- cell_ids

#Calculating the module scores where module score refers to a composite score that represents the activity or expression level of a predefined set of marker genes associated with a particular biological module, cell state, or cell type within a cell population.
singles_only <- AddModuleScore(singles_only, features = marker_genes, name = "module_score")

#Figure 6: Cell Clusters Annotated Manually by Variable Genes
#Plotting UMAP with our clusters annotated by the genes (manually)
DimPlot(singles_only, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
#Note, I do not trust these as they are different than our reference annotations
#I guess that what happens when you try to do it yourself... (trust the reference database instead)

#Alternatively, visualize the updated clusters
#DimPlot(singles_only, group.by = "ident")
```

## Plotting the marker expression
    -`VlnPlot()` shows expression probability distribution across clusters of the genes you specify
    -Can view raw counts as well
    -Can also use `RidgePlot()`, `CellScatter()` and `DotPlot()` as additional viewing methods 
    -`FeaturePlot()` will show the classic umap plot with the genes you specify as features
    -`DoHeatmap()` will generate an expression heatmap for given cells and features
        --This is the classic heatmap that separates every cluster by DEGs
```{r, echo = F, warning = F}
#Figure 7: Expression of immune cell features 
#PDCD1 & CTLA4 are cell checkpoint proteins and will suppress cells of the immune system, leading to immune cell dysregulation and a lack of effective immune resposne. GZMK & CD8A are markers for activated (T-cells) cells and CD8+ T-cells specifically. MS4A1 and IGHG1 are markers for B-cells and IgG1 + B-cells 
FeaturePlot(singles_only, features = c("PDCD1", "CTLA4", 'GZMK', "CD8A", 'MS4A1', 'IGHG1'))

#Alternative gene expression plots
#VlnPlot(singles_only, features = "PDCD1", group.by = 'singleR.labels') + NoLegend()
#RidgePlot(singles_only, features = 'PDCD1', group.by = 'singleR.labels') + NoLegend()
#FeaturePlot(singles_only, features = 'PDCD1', label = T, repel = T)

#Plotting raw counts as well:
#VlnPlot(singles_only, features = c("GZMK", "GZMH", 'CXCL13'), slot = "counts", log = TRUE)

#Figure 8: Expression patterns of exhausted CD8+ T-cells
#Alternative showing overlapping expression of CD8A and LAG3
FeaturePlot(singles_only, features = c('CD8A', 'LAG3'), blend = T)

#Alternative showing many reference genes for different cell types
#FeaturePlot(singles_only, features = c("IL7R", "CCR7", "CD14", "LYZ", "MS4A1", "S100A4", "CD8A", "FCGR3A", "MS4A7", "GNLY", "NKG7", "FCER1A", "CST3"))

#Same as above but different
#FeaturePlot(singles_only, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ","CD8A"))

singles_only.markers %>%
  group_by(cluster) %>% 
  dplyr::filter(avg_log2FC > 1) %>% #specifying the log2FC cutoff value
  slice_head(n = 6) %>% #Specifying the number of top genes that define each cluster on the heatmap
  ungroup() -> top6

#Figure 9: Differential gene expression heatmap by cell cluster
#Showing a heatmap of the top 6 differentially expressed genes for each cluster 
DoHeatmap(singles_only, features = top6$gene) + NoLegend()
```

#Saving the Seurat object
```{r, echo = F}
saveRDS(singles_only, file = 'BIOL668_RJones_Final_Project.rds')
```

#Citations
```{r}
citation(package = 'tidyverse')
citation(package = 'BiocManager')
citation(package = 'Seurat')
citation(package = 'DoubletFinder')
citation(package = 'patchwork')
citation(package = 'Matrix')
citation(package = 'presto')
citation(package = 'sctransform')
citation(package = 'glmGamPoi')
citation(package = 'SingleR')
citation(package = 'celldex')
citation(package = 'pheatmap')
citation(package = 'scran')
```